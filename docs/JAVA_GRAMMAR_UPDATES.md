# Java Grammar Update Process

This document outlines the procedures for updating the Java grammar and
integrating new language features into Checkstyle.

## Prerequisites

There are some tools and concepts that you should be familiar with before
updating the Java grammar:
 - [ANTLR4](https://www.antlr.org/)
 - Basic knowledge of lexers and parsers
 - [Java Language Specification (JLS)](https://docs.oracle.com/javase/specs/jls/se22/html/index.html)
 - [EBNF](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)

## Basics

A few basics to understand:
 - **Lexer**: A lexer is a program that performs lexical analysis. It takes the
   input text and converts it into tokens. Our lexer grammar is defined [here](https://github.com/checkstyle/checkstyle/blob/master/src/main/resources/com/puppycrawl/tools/checkstyle/grammar/java/JavaLanguageLexer.g4).
 - **Parser**: A parser is a program that performs syntax analysis. It takes the
   tokens generated by the lexer and constructs a parse tree. Our parser grammar
   is defined [here](https://github.com/checkstyle/checkstyle/blob/master/src/main/resources/com/puppycrawl/tools/checkstyle/grammar/java/JavaLanguageParser.g4).
 - **Parse Tree**: A parse tree is a tree representation of the syntactic structure
   of the source code. It is generated by the parser. We do not use the parse tree
   directly in Checkstyle, but we use the parser to generate the parse tree and
   then visit the parse tree to build our Abstract Syntax Tree (AST).
 - **Abstract Syntax Tree (AST)**: An AST is a tree representation of the
   syntactic structure of the source code. We build our AST by visiting the parse
   tree generated by the parser. We use the AST to perform static analysis.
 - **Token**: A token is a single element of the source code. For example, a
   keyword, an identifier, a literal, etc. We define tokens in our lexer grammar.
 - **Token Type**: A token type is a category of tokens. For example, `IDENT`
   is a token type that includes all identifiers in the source code. We define
   token types in our lexer grammar.
 - **Parser Rule**: A parser rule is a rule that defines the syntax of the
   programming language. For example, a class declaration.
 - **Parser Rule Context**: A parser rule context is a context in which a parser
   rule is applied, and contains information about the source code that matches
   the parser rule. We use parser rule contexts to build our AST.
 - **Visitor**: A visitor is a design pattern that allows us to separate the
   algorithm from the object structure. We use a visitor to traverse the parse
   tree and build our AST.
 - **JavaAstVisitor**: A visitor that we use to traverse the parse tree and build
   our AST. We define our visitors [here](https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/JavaAstVisitor.java).

## Java Grammar Update Procedure

Let's walk through an example of updating the Java grammar to support a new language feature. We will use the `when`
expression as an example: https://openjdk.org/jeps/441.

### Review the JEP and JLS

It is good to first take some time to read the JEP to understand the new language feature.
The JEP provides detailed information about the goals and motivations behind the new feature,
And help us to come up with good testing strategies.

It is also important to review the Java Language Specification (JLS) to understand the syntax
and semantics of the new language feature. The JLS provides the formal definition of the Java
programming language and is the ultimate reference for language features.

The JLS defines the `when` expression as follows (surrounding context provided for clarity):

```
SwitchBlock:
  { SwitchRule {SwitchRule} }
  { {SwitchBlockStatementGroup} {SwitchLabel :} }

SwitchRule:
  SwitchLabel -> Expression ;
  SwitchLabel -> Block
  SwitchLabel -> ThrowStatement

SwitchBlockStatementGroup:
  SwitchLabel : {SwitchLabel :} BlockStatements

SwitchLabel:
  case CaseConstant {, CaseConstant}
  case null [, default]
  case CasePattern {, CasePattern} [Guard]
  default

CaseConstant:
  ConditionalExpression

CasePattern:
  Pattern
  
Guard:
  when Expression
```

### Identify New Tokens and Update Lexer Grammar

Not every new language feature requires new tokens. But in the case of the `when` expression,
we need to introduce new tokens to represent the `when` keyword. This requires an update
to the lexer grammar.

```antlr
LITERAL_WHEN : 'when' ;
```

Note: we preface literal tokens with `LITERAL_` to distinguish them from other tokens.

We will also need to add a new [TokenType](https://github.com/checkstyle/checkstyle/blob/master/src/main/java/com/puppycrawl/tools/checkstyle/api/TokenTypes.java)
in this case. However, we may not need to always add a token type for every new lexer token, it depends on the use case.

### Update Parser Grammar

Next, we need to update the parser grammar to recognize the new tokens. We need to add a new parser rule
for the `when` expression. The `when` expression is used in the context of a guard in a switch statement or
switch expression. We need to update the `guard` rule to recognize the `when` expression.

```antlr
guardedPattern
    : primaryPattern guard expression
    ;

guard: ( LAND | LITERAL_WHEN );
```

### Update JavaAstVisitor

Now, our lexer recognizes the `when` keyword, and our parser recognizes the `when` expression. We have updated
TokenTypes to include `LITERAL_WHEN`. At this point, we are able to parse the new syntax, however, the new tokens
will not appear in the AST unless we update the JavaAstVisitor.

```java
    @Override
    public DetailAstImpl visitGuardedPattern(JavaLanguageParser.GuardedPatternContext ctx) {
        // since the `guard` rule is a terminal rule, we need to create a new AST node for it
        final DetailAstImpl guardAstNode = flattenedTree(ctx.guard());
        // we add the children of the `primaryPattern` and `expression` rules to the AST node
        guardAstNode.addChild(visit(ctx.primaryPattern()));
        guardAstNode.addChild(visit(ctx.expression()));
        return guardAstNode;
    }
```

### Update Tests

Finally, we need to update our tests to ensure that the new language feature is correctly parsed and analyzed. You
can find our AST tests [here](https://github.com/checkstyle/checkstyle/tree/master/src/test/java/com/puppycrawl/tools/checkstyle/grammar).
We typically separate tests into directories based on the language level.

## Additional Considerations

### DetailAstPair

The `DetailAstPair` class is used to represent a pair of AST nodes. It is used in the `JavaAstVisitor` to
represent the nested parent-child relationship between AST nodes.

### Imaginary Tokens
We often create "Imaginary tokens" to represent the structure of the source code. These tokens are not
directly generated by the lexer (or parser in most cases) but are used to represent the structure of the source
code in the AST, and ease the process of static analysis. An example of this is the `EXPR` token; no such token
is generated by the lexer, but it is used to represent expressions in the AST to make it easy for checks to find
and analyze expressions.