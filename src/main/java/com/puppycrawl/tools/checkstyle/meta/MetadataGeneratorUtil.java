///////////////////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code and other text files for adherence to a set of rules.
// Copyright (C) 2001-2023 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
///////////////////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.meta;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import com.google.common.collect.Lists;
import com.puppycrawl.tools.checkstyle.AbstractAutomaticBean.OutputStreamOptions;
import com.puppycrawl.tools.checkstyle.Checker;
import com.puppycrawl.tools.checkstyle.DefaultConfiguration;
import com.puppycrawl.tools.checkstyle.MetadataGeneratorLogger;
import com.puppycrawl.tools.checkstyle.TreeWalker;
import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
import com.puppycrawl.tools.checkstyle.api.DetailNode;
import com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;
import com.puppycrawl.tools.checkstyle.checks.TodoCommentCheck;
import com.puppycrawl.tools.checkstyle.site.SiteUtil;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;
import com.puppycrawl.tools.checkstyle.utils.JavadocUtil;
import org.apache.maven.doxia.macro.MacroExecutionException;

/** Class which handles all the metadata generation and writing calls. */
public final class MetadataGeneratorUtil {

    /** Regular expression for detecting ANTLR tokens(for e.g. CLASS_DEF). */
    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile("([A-Z_]{2,})+");

    /**
     * Modules whose metadata is generated by functionality shared with SiteUtil, not
     * by JavadocMetadataScraper.
     * Until <a href="https://github.com/checkstyle/checkstyle/issues/13626">#13626</a>
     */
    private static final Set<String> MODULES_GENERATED_BY_NEW_FUNCTIONALITY = Set.of(
        "TodoCommentCheck.java"
    );

    /** Stop instances being created. **/
    private MetadataGeneratorUtil() {
    }

    /**
     * Generate metadata from the module source files available in the input argument path.
     *
     * @param path arguments
     * @param out OutputStream for error messages
     * @param moduleFolders folders to check
     * @throws IOException ioException
     * @throws CheckstyleException checkstyleException
     * @throws MacroExecutionException macroExecutionException
     */
    public static void generate(String path, OutputStream out, String... moduleFolders)
            throws IOException, CheckstyleException, MacroExecutionException {
        JavadocMetadataScraper.resetModuleDetailsStore();

        final Checker checker = new Checker();
        checker.setModuleClassLoader(Checker.class.getClassLoader());
        final DefaultConfiguration scraperCheckConfig =
                        new DefaultConfiguration(JavadocMetadataScraper.class.getName());
        final DefaultConfiguration defaultConfiguration =
                new DefaultConfiguration("configuration");
        final DefaultConfiguration treeWalkerConfig =
                new DefaultConfiguration(TreeWalker.class.getName());
        defaultConfiguration.addProperty("charset", StandardCharsets.UTF_8.name());
        defaultConfiguration.addChild(treeWalkerConfig);
        treeWalkerConfig.addChild(scraperCheckConfig);
        checker.configure(defaultConfiguration);

        checker.addListener(new MetadataGeneratorLogger(out, OutputStreamOptions.NONE));

        final List<File> moduleFiles = getTargetFiles(path, moduleFolders);
        final List<File> moduleFilesForNewMetadata = moduleFiles.stream().filter(file -> {
            final String fileName = file.getName();
            return MODULES_GENERATED_BY_NEW_FUNCTIONALITY.contains(fileName);
        }).collect(Collectors.toList());
        moduleFiles.removeAll(moduleFilesForNewMetadata);

        checker.process(moduleFiles);

        //////////////////////////////
        // Plan:
        // 1. Module name
        //    - get from file name
        //    - remove "Check"
        // 2. Fully qualified name
        //    clss.getName()
        // 3. Parent
        //    SiteUtil.getParentModule(clss)
        // 4. ModuleType
        //    - use getModuleType() from JavadocMetadataScraper
        // 5. Description
        //    - everything in javadoc is description
        // 6. Violation message keys
        //    - SiteUtil.getMessageKeys(clss)
        //////////////////////////////
        for (File file: moduleFilesForNewMetadata) {
            final ModuleDetails moduleDetails = new ModuleDetails();

            String moduleName = getModuleName(file);
            final String checkModuleExtension = "Check";
            if (moduleName.endsWith(checkModuleExtension)) {
                moduleName = moduleName
                        .substring(0, moduleName.length() - checkModuleExtension.length());
            }
            moduleDetails.setName(moduleName);

            // TODO: Move to shared module, because that MacroExecutionException doesn't belong here
            final Object instance = SiteUtil.getModuleInstance(moduleName);
            final Class<?> clss = instance.getClass();
            final String fullyQualifiedName = clss.getName();
            moduleDetails.setFullQualifiedName(fullyQualifiedName);

            final String parentModule = SiteUtil.getParentModule(clss);
            final Object parentModuleInstance = SiteUtil.getModuleInstance(parentModule);
            moduleDetails.setParent(parentModuleInstance.getClass().getName());

            final ModuleType moduleType = getModuleType(moduleName);
            moduleDetails.setModuleType(moduleType);

            final Set<String> messageKeys = SiteUtil.getMessageKeys(clss);
            moduleDetails.addToViolationMessages(new ArrayList<>(messageKeys));

            final String className = getModuleName(file);
            final Set<String> properties = SiteUtil.getPropertiesForDocumentation(clss, instance);
            final Map<String, DetailNode> javadocs = SiteUtil
                    .getPropertiesJavadocs(properties, className, file);
            final DetailNode moduleJavadoc = javadocs.get(className);
            moduleDetails.setDescription(constructSubTreeText(moduleJavadoc));

            final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();

            for (String property : properties) {
                final ModulePropertyDetails propertyDetails = new ModulePropertyDetails();
                propertyDetails.setName(property);

                final DetailNode propertyJavadoc = javadocs.get(property);
                String propertyDescription = constructSubTreeText(propertyJavadoc)
                        .substring("Setter to ".length());
                final String firstLetterCapitalized = propertyDescription.substring(0, 1)
                    .toUpperCase(Locale.ROOT);
                propertyDescription = firstLetterCapitalized + propertyDescription.substring(1);
                propertyDetails.setDescription(propertyDescription);

                final Field field = SiteUtil.getField(clss, property);
                final Class<?> propertyType = SiteUtil.getFieldClass(field, property, className, instance);
                propertyDetails.setType(propertyType.getName());

                final String defaultValue = SiteUtil.getDefaultValue(property, field, instance, className);
                final String defaultValueWihtoutQuotes = defaultValue.substring( 1, defaultValue.length() - 1 );
                propertyDetails.setDefaultValue(defaultValueWihtoutQuotes);

                moduleDetails.addToProperties(propertyDetails);
            }

            try {
                XmlMetaWriter.write(moduleDetails);
            }
            catch (TransformerException | ParserConfigurationException ex) {
                throw new IllegalStateException(
                                "Failed to write metadata into XML file for module: "
                                        + "todoComment", ex);
            }
        }

    }

    private static String constructSubTreeText(DetailNode javadoc) {
        DetailNode detailNode = null;

        final Deque<DetailNode> stack = new ArrayDeque<>();
        final List<DetailNode> descriptionNodes = getDescriptionNodes(javadoc);
        Lists.reverse(descriptionNodes).forEach(stack::push);
        final StringBuilder result = new StringBuilder(1024);
        while (!stack.isEmpty()) {
            detailNode = stack.pop();

            Lists.reverse(Arrays.asList(detailNode.getChildren())).forEach(stack::push);

            final String childText = detailNode.getText();
            if (detailNode.getType() != JavadocTokenTypes.LEADING_ASTERISK
                    && !TOKEN_TEXT_PATTERN.matcher(childText).matches()) {
                result.append(childText);
            }
        }
        return result.toString().trim();
    }

    /**
     * Extracts description nodes from javadoc.
     *
     * @param javadoc the Javadoc to extract the description from.
     * @return the description nodes of the setter.
     */
    private static List<DetailNode> getDescriptionNodes(DetailNode javadoc) {
        final DetailNode[] children = javadoc.getChildren();
        final List<DetailNode> descriptionNodes = new ArrayList<>();
        for (final DetailNode child : children) {
            if (isEndOfDescription(child)) {
                break;
            }
            descriptionNodes.add(child);
        }
        return descriptionNodes;
    }

    /**
     * Determines if the given child index is the end of the description. The end of the
     * description is defined as 4 consecutive nodes of type NEWLINE, LEADING_ASTERISK, NEWLINE,
     * LEADING_ASTERISK. This is an asterisk that is alone on a line. Just like the one below
     * this line.
     *
     * @param child the child to check.
     * @return true if the given child index is the end of the description.
     */
    private static boolean isEndOfDescription(DetailNode child) {
        final DetailNode nextSibling = JavadocUtil.getNextSibling(child);
        final DetailNode secondNextSibling = JavadocUtil.getNextSibling(nextSibling);
        final DetailNode thirdNextSibling = JavadocUtil.getNextSibling(secondNextSibling);

        return child.getType() == JavadocTokenTypes.NEWLINE
                    && nextSibling.getType() == JavadocTokenTypes.LEADING_ASTERISK
                    && secondNextSibling.getType() == JavadocTokenTypes.NEWLINE
                    && thirdNextSibling.getType() == JavadocTokenTypes.LEADING_ASTERISK;
    }

    /**
     * Get the module name from the file. The module name is the file name without the extension.
     * If the module name ends with "Check", then it's removed.
     *
     * @param file file to extract the module name from.
     * @return module name.
     */
    private static String getModuleName(File file) {
        final String fullFileName = file.getName();
        return CommonUtil.getFileNameWithoutExtension(fullFileName);
    }

    /**
     * Get module type(check/filter/filefilter) based on module name.
     *
     * @param moduleName module name.
     * @return module type.
     */
    private static ModuleType getModuleType(String moduleName) {
        final ModuleType result;
        if (moduleName.endsWith("FileFilter")) {
            result = ModuleType.FILEFILTER;
        }
        else if (moduleName.endsWith("Filter")) {
            result = ModuleType.FILTER;
        }
        else {
            result = ModuleType.CHECK;
        }
        return result;
    }

    /**
     * Get files that represent modules.
     *
     * @param moduleFolders folders to check
     * @param path          rootPath
     * @return files for scrapping javadoc and generation of metadata files
     * @throws IOException ioException
     */
    private static List<File> getTargetFiles(String path, String... moduleFolders)
            throws IOException {
        final List<File> validFiles = new ArrayList<>();
        for (String folder : moduleFolders) {
            try (Stream<Path> files = Files.walk(Paths.get(path + "/" + folder))) {
                validFiles.addAll(
                        files.map(Path::toFile)
                        .filter(file -> {
                            final String fileName = file.getName();
                            return fileName.endsWith("SuppressWarningsHolder.java")
                                    || fileName.endsWith("Check.java")
                                    || fileName.endsWith("Filter.java");
                        })
                        .collect(Collectors.toList()));
            }
        }

        return validFiles;
    }
}
