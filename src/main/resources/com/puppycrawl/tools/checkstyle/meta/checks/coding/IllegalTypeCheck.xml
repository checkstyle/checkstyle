<?xml version="1.0" encoding="UTF-8"?>

<checkstyle-metadata>
  <module>
    <check name="IllegalType" fully-qualified-name="com.puppycrawl.tools.checkstyle.checks.coding.IllegalTypeCheck" parent="com.puppycrawl.tools.checkstyle.TreeWalker">
      <description><![CDATA[<p>
 Checks that particular classes or interfaces are never used.
 </p>
 <p>
 Rationale: Helps reduce coupling on concrete classes.
 </p>
 <p>
 For additional restriction of type usage see also:
 <a href="https://checkstyle.org/config_coding.html#IllegalInstantiation">
 IllegalInstantiation</a>,
 <a href="https://checkstyle.org/config_imports.html#IllegalImport">IllegalImport</a>
 </p>
 <p>
 It is possible to set illegal class names via short or
 <a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.7">canonical</a>
 name. Specifying illegal type invokes analyzing imports and Check puts violations at
 corresponding declarations (of variables, methods or parameters).
 This helps to avoid ambiguous cases, e.g.: {@code java.awt.List} was set as
 illegal class name, then, code like:
 </p>
 <pre>
 import java.util.List;
 ...
 List list; //No violation here
 </pre>
 <p>
 will be ok.
 </p>
 <p>
 In most cases it's justified to put following classes to <b>illegalClassNames</b>:
 </p>
 <ul>
 <li>GregorianCalendar</li>
 <li>Hashtable</li>
 <li>ArrayList</li>
 <li>LinkedList</li>
 <li>Vector</li>
 </ul>
 <p>
 as methods that are differ from interface methods are rarely used, so in most cases user will
 benefit from checking for them.
 </p>]]></description>
      <properties>
        <property name="validateAbstractClassNames" type="boolean" default-value="false">
          <description><![CDATA[Control whether to validate abstract class names.]]></description>
        </property>
        <property name="illegalClassNames" type="java.lang.String[]" default-value="HashMap, HashSet, LinkedHashMap, LinkedHashSet, TreeMap,">
          <description><![CDATA[Specify classes that should not be used
 as types in variable declarations, return values or parameters.]]></description>
        </property>
        <property name="legalAbstractClassNames" type="java.lang.String[]" default-value="">
          <description><![CDATA[Define abstract classes that may be used as types.]]></description>
        </property>
        <property name="ignoredMethodNames" type="java.lang.String[]" default-value="getEnvironment, getInitialContext">
          <description><![CDATA[Specify methods that should not be checked.]]></description>
        </property>
        <property name="illegalAbstractClassNameFormat" type="java.util.regex.Pattern" default-value="^(.*[.])?Abstract.*$">
          <description><![CDATA[Specify RegExp for illegal abstract class
 names.]]></description>
        </property>
        <property name="memberModifiers" type="java.lang.String[]" default-value="no tokens" validation-type="tokenSet">
          <description><![CDATA[Control whether to check only methods and fields with any
 of the specified modifiers.
 This property does not affect method calls nor method references.]]></description>
        </property>
        <property name="tokens" type="java.lang.String[]" default-value="ANNOTATION_FIELD_DEF,CLASS_DEF,INTERFACE_DEF,METHOD_CALL,METHOD_DEF,METHOD_REF,PARAMETER_DEF,VARIABLE_DEF,PATTERN_VARIABLE_DEF" validation-type="tokenSet">
          <description><![CDATA[tokens to check]]></description>
        </property>
      </properties>
      <message-keys>
        <message-key key="illegal.type"/>
      </message-keys>
    </check>
  </module>
</checkstyle-metadata>
