array.trailing.comma=配列ではカンマが行末に来るようにすべきです。

assignment.inner.avoid=式内部での代入は避けるべきです。

covariant.equals=equals(java.lang.Object) をオーバーライドせずに共変 な equals を定義しています。

empty.statement=空の文です。

equals.noHashCode=''equals()'' を定義していますが、これに対応する ''hashCode()'' の定義がありません。

final.variable=変数 ''{0}'' は final として宣言すべきです。

hidden.field=''{0}'' がフィールドを隠しています。

illegal.token=''{0}'' の使用は許可されていません。

illegal.token.text=トークンのテキストが不正なパターン ''{0}'' に一致しています。

instantiation.avoid={0} のインスタンス化は避けるべきです。

magic.number=''{0}'' はマジックナンバーです。

missing.super.call=メソッド ''{0}'' は ''super.{0}'' を呼ぶべきです。
missing.switch.default=\"default\" 節の無い switch 文です。

redundant.throws.classInfo={0} のクラス情報が取得できません。
redundant.throws.duplicate=冗長な throws: ''{0}'' が重複しています。
redundant.throws.subclass=冗長な throws: ''{0}'' は ''{1}'' のサブクラスです。
redundant.throws.unchecked=冗長な throws: ''{0}'' はチェックされない例外です。

simplify.boolReturn=条件ロジックはなくせます。
simplify.expression=表現は簡潔にできます。

nested.if.depth=ネストした if-else の深さが {0,number,integer} （最大 {1,number,integer} まで）です。
nested.try.depth=ネストした try の深さが {0,number,integer} （最大 {1,number,integer} まで）です。

string.literal.equality=リテラルの文字列は ''{0}'' ではなく、 equals() を使用して比較するべきです。

illegal.catch=''{0}'' をキャッチすることは許可されていません。
missing.package.declaration=package 宣言が見つかりません。

return.count=return が {0,number,integer} 個所あります（最大 {1,number,integer} まで）。

illegal.type=''{0}'' 型の変数、戻り値、パラメータを宣言することは許可されていません。

declaration.order.constructor=コンストラクタの定義順序が間違っています。
declaration.order.static=static 変数の定義順序が間違っています。
declaration.order.instance=インスタンス変数の定義順序が間違っています。
declaration.order.access=変数アクセスの定義順序が間違っています。

parameter.assignment=パラメータ ''{0}'' への代入は許可されていません。

explicit.init=変数 ''{0}'' が明示的に ''{1}'' (この型のデフォルト値）に初期化されています。

avoid.finalizer.method = ファイナライザメソッドを使用しないでください。
avoid.clone.method = cloneメソッドを使用しないでください。
default.comes.last = デフォルトでは、スイッチ内の最後のラベルである必要があります。
equals.avoid.null = 比較に等しい文字列リテラル式は、左側にある必要があります。
equalsIgnoreCase.avoid.null = 文字列リテラル式は equalsIgnoreCase 比較の左側に配置する必要があります。
fall.through = switch文の前のブランチから通って落下しています。
fall.through.last = switch文の最後のブランチから通って落下しています。
inline.conditional.avoid = インライン条件文を避けてください。
missing.ctor = クラスは、コンストラクタを定義する必要があります。
modified.control.variable = 制御変数は、 ''{0}'' に変更されます。
multiple.statements.line = 行に1つの文だけが許可されます。
multiple.string.literal = 文字列 {0} は、このファイルに {1} に出現しています。
multiple.variable.declarations = 行に1つの変数定義だけが許可されます。
multiple.variable.declarations.comma = 各変数の宣言には、独自のステートメントでなければなりません。
nested.for.depth = 入れ子のforの深さ {0,number,integer}（許可された最大値は{1,number,integer})。
require.this.variable = インスタンス変数 ''{0}'' への参照には \"{1}this.\" が必要です。
require.this.method = メソッド ''{0}'' への呼び出しは、 \"{1}this.\" が必要です。
unnecessary.paren.assign = 代入右辺の周りに不要な括弧。
unnecessary.paren.expr = 式の周りの不要な括弧。
unnecessary.paren.ident = 識別子の前後に不要な括弧 ''{0}''。
unnecessary.paren.literal = 文字通りの周りに不要な括弧 ''{0}''。
unnecessary.paren.return = 戻り値の周りの不要な括弧。
unnecessary.paren.string = 文字列の周りに不要な括弧 {0}
package.dir.mismatch = パッケージの宣言はディレクトリと一致していません ''{0}''。
variable.declaration.usage.distance = 変数  ''{0}'' の宣言と、その変数の使用開始位置までの距離が  {1} です。許可された距離 は {2} です。
variable.declaration.usage.distance.extend = 変数  ''{0}'' の宣言と、その変数の使用開始位置までの距離が  {1} です。許可された距離 は {2} です。 もし、事前(元の値への副作用をともなうメソッド呼び出しの前)に、その値を格納する必要があるのであれば、その変数をfinalとすることを検討してください。
overload.methods.declaration = オーバーロードメソッドは、分割すべきではありません。ラインにある前のオーバーロードされたメソッド ''{0}''。
doublechecked.locking.avoid = ダブルチェックロッキング（DCL  - デュアルコントロールのロック機構）。
illegal.throw= ''{0}'' をスローすることは許可されていません。
