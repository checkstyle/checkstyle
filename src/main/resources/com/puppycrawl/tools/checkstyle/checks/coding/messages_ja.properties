array.trailing.comma=配列ではカンマが行末に来るようにすべきです。

assignment.inner.avoid=式内部での代入は避けるべきです。

covariant.equals=equals(java.lang.Object) をオーバーライドせずに covariant な equals を定義しています。

empty.statement=空の文です。

equals.noHashCode=''equals()'' を定義していますが、これに対応する ''hashCode()'' の定義がありません。

final.variable=変数 ''{0}'' は final として宣言すべきです。

hidden.field=''{0}'' がフィールドを隠しています。

illegal.token=''{0}'' の使用は許可されていません。

illegal.token.text=トークンのテキストが不正なパターン ''{0}'' に一致しています。

instantiation.avoid={0} のインスタンス化は避けるべきです。

magic.number=''{0}'' はマジックナンバーです。

missing.super.call=メソッド ''{0}'' は ''super.{0}'' を呼ぶべきです。
missing.switch.default=\"default\" 節の無い switch 文です。

redundant.throws.classInfo={0} のクラス情報が取得できません。
redundant.throws.duplicate=冗長な throws: ''{0}'' が重複しています。
redundant.throws.subclass=冗長な throws: ''{0}'' は ''{1}'' のサブクラスです。
redundant.throws.unchecked=冗長な throws: ''{0}'' はチェックされない例外です。

simplify.boolReturn=条件ロジックはなくせます。
simplify.expression=表現は簡潔にできます。

nested.if.depth=ネストした if-else の深さが {0,number,integer} （最大 {1,number,integer} まで）です。
nested.try.depth=ネストした try の深さが {0,number,integer} （最大 {1,number,integer} まで）です。

string.literal.equality=リテラルの文字列は ''{0}'' ではなく、 equals() を使用して比較するべきです。

illegal.catch=''{0}'' をキャッチすることは許可されていません。
missing.package.declaration=package 宣言が見つかりません。

return.count=return が {0,number,integer} 個所あります（最大 {1,number,integer} まで）。

illegal.type=''{0}'' 型の変数、戻り値、パラメータを宣言することは許可されていません。

declaration.order.constructor=コンストラクタの定義順序が間違っています。
declaration.order.static=static 変数の定義順序が間違っています。
declaration.order.instance=インスタンス変数の定義順序が間違っています。
declaration.order.access=変数アクセスの定義順序が間違っています。

parameter.assignment=パラメータ ''{0}'' への代入は許可されていません。

explicit.init=変数 ''{0}'' が明示的に ''{1}'' （この型のデフォルト値）に初期化されています。

avoid.finalizer.method = ファイナライザメソッドを使用しないでください。
avoid.clone.method = cloneメソッドを使用しないでください。
default.comes.last = デフォルトでは、スイッチ内の最後のラベルである必要があります。
equals.avoid.null = 比較に等しい文字列リテラル式は、左側にある必要があります。
equalsIgnoreCase.avoid.null = 文字列リテラル式は equalsIgnoreCase 比較の左側に配置する必要があります。
fall.through = switch文の前のブランチから通って落下。
fall.through.last = switch文の最後のブランチから通って落下。
inline.conditional.avoid = インライン条件文を避けてください。
missing.ctor = クラスは、コンストラクタを定義する必要があります。
modified.control.variable = 制御変数は、 ''{0}'' に変更されます。
multiple.statements.line = 行ごとに1つの文では、許可されました。
multiple.string.literal = 文字列{0}表示されます {1} ファイルに回。
multiple.variable.declarations = 行ごとに1つの変数の定義ができました。
multiple.variable.declarations.comma = 各変数の宣言には、独自のステートメントでなければなりません。
nested.for.depth = 深さのためであるネストされた{0、番号、整数}（許可された最大値は{1、数、整数}）。
require.this.variable = インスタンス変数への参照は、 ''{0}'' \"これを。\" 」が必要です。
require.this.unfound.variable = できません どこで見つける ''{0}'' 宣言されています。
require.this.method = 」へのメソッド呼び出しは、 ''{0}'' \"これを。\" 」が必要です。
unnecessary.paren.assign = 代入右辺の周りに不要な括弧。
unnecessary.paren.expr = 式の周りの不要な括弧。
unnecessary.paren.ident = 識別子の前後に不要な括弧 ''{0}''。
unnecessary.paren.literal = 文字通りの周りに不要な括弧 ''{0}''。
unnecessary.paren.return = 戻り値の周りの不要な括弧。
unnecessary.paren.string = 文字列の周りに不要な括弧 {0}
package.dir.mismatch = パッケージの宣言は''ディレクトリと一致していません ''{0}''。
variable.declaration.usage.distance = 変数 との間の距離{0} の宣言と、その最初の使用されている ''{1}'' が、許可された {2}
variable.declaration.usage.distance.extend = 変数 との間の距離 ''{0}''の宣言と、その最初の使用されている {1} が、許可された {2} あなたはまだ（元の値に副作用を行う可能性がありますメソッドの呼び出し前）に、事前にその値を格納する必要がある場合、最終的なように、その変数を作成することを検討してください。
overload.methods.declaration = オーバーロードメソッドは、分割すべきではありません。ラインにある前のオーバーロードされたメソッド ''{0}''。
doublechecked.locking.avoid = ダブルチェックロッキング（DCL  - デュアルコントロールのロック機構）。
illegal.throw=投げる ''{0}'' は許可されていません。
