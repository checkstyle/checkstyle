array.trailing.comma=O array deveria ter uma virgula final.
assignment.inner.avoid=Atribui√ß√µes aninhadas devem ser evitadas.
avoid.clone.method=Evite o uso do m√©todo ''clone()''.
avoid.double.brace.init=Evite a inicializa√ß√£o entre chaves.
avoid.finalizer.method=Evite o uso do m√©todo ''finalize()''.
constructors.declaration.grouping=Os construtores devem ser agrupados. O √∫ltimo construtor agrupado √© declarado na linha ''{0}''.
covariant.equals="equals" covariante sem sobrescrever ''equals(java.lang.Object)''.
declaration.order.access=Defini√ß√£o de acesso a vari√°vel em ordem errada.
declaration.order.constructor=Defini√ß√£o de construtor em ordem errada.
declaration.order.instance=Defini√ß√£o de vari√°vel de inst√¢ncia em ordem errada.
declaration.order.static=Defini√ß√£o de vari√°vel est√°tica em ordem errada.
default.comes.last=O "default" deve ser a √∫ltima entrada no "switch".
default.comes.last.in.casegroup=O "default" deve ser a √∫ltima entrada no grupo de "case"s.
empty.statement=Instru√ß√£o vazia.
equals.avoid.null=Literais de String deveriam estar no lado esquerdo de compara√ß√µes feitas com "equals".
equals.noEquals=O m√©todo ''hashCode()'' deveria ser acompanhado de um m√©todo ''equals(Object)''.
equals.noHashCode=O m√©todo ''equals(Object)'' deveria ser acompanhado de um m√©todo ''hashCode()''.
equalsIgnoreCase.avoid.null=Literais de String deveriam estar no lado esquerdo de compara√ß√µes feitas com equalsIgnoreCase.
explicit.init=A vari√°vel ''{0}'' foi inicializada explicitamente com ''{1}'' (valor padr√£o para o seu tipo).
fall.through=Continua√ß√£o (fallthrough) vindo da ramifica√ß√£o anterior da instru√ß√£o switch.
fall.through.last=Continua√ß√£o (fallthrough) para al√©m da √∫ltimo ramifica√ß√£o da instru√ß√£o switch.
final.variable=A vari√°vel ''{0}'' deveria ser declarada final.
hidden.field=''{0}'' esconde um campo.
illegal.catch=Capturar ''{0}'' n√£o √© permitido.
illegal.throw=Lan√ßar ''{0}'' n√£o √© permitido.
illegal.token=N√£o √© permitida a utiliza√ß√£o de ''{0}''.
illegal.token.text=Elemento de texto coincide com o padr√£o ilegal ''{0}''.
illegal.type=O uso do tipo ''{0}'' n√£o √© permitido.
inline.conditional.avoid=Evite condicionais inline.
inline.variable=Inline ''{0}'' for immediate return or throw.
instantiation.avoid=A instancia√ß√£o de {0} deve ser evitada.
magic.number=''{0}'' √© um n√∫mero m√°gico.
matchxpath.match=Estrutura de c√≥digo ilegal detectada.
mismatch.package.directory=O nome do pacote n√£o √© o mesmo que o do diret√≥rio.
missing.ctor=A classe deve definir um construtor.
missing.package.declaration=Falta a declara√ß√£o de pacote.
missing.super.call=O m√©todo ''{0}'' deveria invocar ''super.{0}''.
missing.switch.default="switch" sem a ramifica√ß√£o "default".
missing.switch.nullcase=Switch usando tipos de refer√™ncia deveria ter um caso nulo.
modified.control.variable=Vari√°vel de controle ''{0}'' √© modificada.
multiple.statements.line=Apenas uma instru√ß√£o por linha √© permitida.
multiple.string.literal=A String {0} aparece {1} vezes no arquivo.
multiple.variable.declarations=Apenas uma defini√ß√£o de vari√°vel por linha √© permitida.
multiple.variable.declarations.comma=Cada declara√ß√£o de vari√°vel deve estar em sua pr√≥pria instru√ß√£o.
nested.for.depth=A profundidade de aninhamento do "for" √© {0, number, integer} (o m√°ximo permitido √© {1,number,integer}).
nested.if.depth=A profundidade de aninhamento do "if-else" √© {0,number,integer} (o m√°ximo permitido √© {1,number,integer}).
nested.try.depth=A profundidade de aninhamento do "try" √© {0,number,integer} (o m√°ximo permitido √© {1,number,integer}).
no.array.trailing.comma=A matriz n√£o deve conter v√≠rgula √† direita.
no.enum.trailing.comma=O enum n√£o deve conter v√≠rgula √† direita.
overload.methods.declaration=Todos os m√©todos sobrecarregados devem ser colocados um ao lado do outro. M√©todo sobrecarregado anterior localizado na linha ''{0}''.
parameter.assignment=A atribui√ß√£o ao par√¢metro ''{0}'' n√£o √© permitida.
require.this.method=A chamada de m√©todo no ''{0}'' precisa de "{1}this.".
require.this.variable=A refer√™ncia √† vari√°vel de inst√¢ncia ''{0}'' precisa de "{1}this.".
return.count=O n√∫mero de "return"s √© {0,number,integer} (o m√°ximo permitido para m√©todos n√£o vazios/lambdas √© {1,number,integer}).
return.countVoid=O n√∫mero de "return"s √© {0,number,integer} (o m√°ximo permitido para vazios m√©todos/construtores/lambdas √© {1,number,integer}).
simplify.boolReturn=A l√≥gica condicional pode ser removida.
simplify.expression=A express√£o pode ser simplificada.
string.literal.equality=Literais de String deveriam ser comparados com "equals()", n√£o com ''{0}''.
super.constructor.call=Chamada desnecess√°ria ao construtor da superclasse sem argumentos.
unnecessary.paren.assign=Par√™nteses desnecess√°rios ao redor do lado direito da atribui√ß√£o.
unnecessary.paren.expr=Par√™nteses desnecess√°rios ao redor da express√£o.
unnecessary.paren.ident=Par√™nteses desnecess√°rios ao redor do identificador ''{0}''.
unnecessary.paren.lambda=Par√™nteses desnecess√°rios em torno do valor lambda.
unnecessary.paren.literal=Par√™nteses desnecess√°rios em torno do literal ''{0}''.
unnecessary.paren.return=Par√™nteses desnecess√°rios em torno do valor de retorno.
unnecessary.paren.string=Par√™nteses desnecess√°rios em torno da cadeia {0}.
unnecessary.semicolon=Ponto-e-v√≠rgula desnecess√°rio.
unused.catch.parameter=O par√¢metro catch n√£o utilizado ''{0}'' n√£o deve ter nome.
unused.lambda.parameter=O par√¢metro lambda n√£o utilizado ''{0}'' n√£o deve ter nome.
unused.local.method=MÈtodo local n√£o utilizada '' {0} ''.
unused.local.var=Vari√°vel local n√£o utilizada '' {0} ''.
unused.named.local.var=Vari·vel local nomeada n„o utilizada '' {0} ''.
variable.declaration.usage.distance=A dist√¢ncia entre a declara√ß√£o da vari√°vel ''{0}'' e o seu primeiro uso √© {1}. O m√°ximo permitido √© {2}.
variable.declaration.usage.distance.extend=A dist√¢ncia entre a declara√ß√£o da vari√°vel ''{0}'' e o seu primeiro uso √© {1}. O m√°ximo permitido √© {2}. Considere tornar essa vari√°vel final se voc√™ ainda precisa armazenar o seu valor com anteced√™ncia (antes que chamadas de m√©todos que possam causar efeitos colaterais sobre o seu valor original).
when.should.be.used=A express√£o ''when'' deve ser utilizada em vez de uma √∫nica instru√ß√£o ''if'' no bloco case.
