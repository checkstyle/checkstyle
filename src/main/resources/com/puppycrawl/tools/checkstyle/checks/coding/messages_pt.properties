array.trailing.comma=O array deveria ter uma virgula final.
assignment.inner.avoid=Atribuições aninhadas devem ser evitadas.
avoid.clone.method=Evite o uso do método ''clone()''.
avoid.double.brace.init=Evite a inicialização entre chaves.
avoid.finalizer.method=Evite o uso do método ''finalize()''.
constructors.declaration.grouping=Os construtores devem ser agrupados. O último construtor agrupado é declarado na linha ''{0}''.
covariant.equals="equals" covariante sem sobrescrever ''equals(java.lang.Object)''.
declaration.order.access=Definição de acesso a variável em ordem errada.
declaration.order.constructor=Definição de construtor em ordem errada.
declaration.order.instance=Definição de variável de instância em ordem errada.
declaration.order.static=Definição de variável estática em ordem errada.
default.comes.last=O "default" deve ser a última entrada no "switch".
default.comes.last.in.casegroup=O "default" deve ser a última entrada no grupo de "case"s.
empty.statement=Instrução vazia.
equals.avoid.null=Literais de String deveriam estar no lado esquerdo de comparações feitas com "equals".
equals.noEquals=O método ''hashCode()'' deveria ser acompanhado de um método ''equals(Object)''.
equals.noHashCode=O método ''equals(Object)'' deveria ser acompanhado de um método ''hashCode()''.
equalsIgnoreCase.avoid.null=Literais de String deveriam estar no lado esquerdo de comparações feitas com equalsIgnoreCase.
explicit.init=A variável ''{0}'' foi inicializada explicitamente com ''{1}'' (valor padrão para o seu tipo).
fall.through=Continuação (fallthrough) vindo da ramificação anterior da instrução switch.
fall.through.last=Continuação (fallthrough) para além da último ramificação da instrução switch.
final.variable=A variável ''{0}'' deveria ser declarada final.
hidden.field=''{0}'' esconde um campo.
illegal.catch=Capturar ''{0}'' não é permitido.
illegal.throw=Lançar ''{0}'' não é permitido.
illegal.token=Não é permitida a utilização de ''{0}''.
illegal.token.text=Elemento de texto coincide com o padrão ilegal ''{0}''.
illegal.type=O uso do tipo ''{0}'' não é permitido.
inline.conditional.avoid=Evite condicionais inline.
instantiation.avoid=A instanciação de {0} deve ser evitada.
magic.number=''{0}'' é um número mágico.
matchxpath.match=Estrutura de código ilegal detectada.
mismatch.package.directory=O nome do pacote não é o mesmo que o do diretório.
missing.ctor=A classe deve definir um construtor.
missing.package.declaration=Falta a declaração de pacote.
missing.super.call=O método ''{0}'' deveria invocar ''super.{0}''.
missing.switch.default="switch" sem a ramificação "default".
missing.switch.nullcase=Switch usando tipos de referência deveria ter um caso nulo.
modified.control.variable=Variável de controle ''{0}'' é modificada.
multiple.statements.line=Apenas uma instrução por linha é permitida.
multiple.string.literal=A String {0} aparece {1} vezes no arquivo.
multiple.variable.declarations=Apenas uma definição de variável por linha é permitida.
multiple.variable.declarations.comma=Cada declaração de variável deve estar em sua própria instrução.
nested.for.depth=A profundidade de aninhamento do "for" é {0, number, integer} (o máximo permitido é {1,number,integer}).
nested.if.depth=A profundidade de aninhamento do "if-else" é {0,number,integer} (o máximo permitido é {1,number,integer}).
nested.try.depth=A profundidade de aninhamento do "try" é {0,number,integer} (o máximo permitido é {1,number,integer}).
no.array.trailing.comma=A matriz não deve conter vírgula à direita.
no.enum.trailing.comma=O enum não deve conter vírgula à direita.
overload.methods.declaration=Todos os métodos sobrecarregados devem ser colocados um ao lado do outro. Método sobrecarregado anterior localizado na linha ''{0}''.
parameter.assignment=A atribuição ao parâmetro ''{0}'' não é permitida.
require.this.method=A chamada de método no ''{0}'' precisa de "{1}this.".
require.this.variable=A referência à variável de instância ''{0}'' precisa de "{1}this.".
return.count=O número de "return"s é {0,number,integer} (o máximo permitido para métodos não vazios/lambdas é {1,number,integer}).
return.countVoid=O número de "return"s é {0,number,integer} (o máximo permitido para vazios métodos/construtores/lambdas é {1,number,integer}).
simplify.boolReturn=A lógica condicional pode ser removida.
simplify.expression=A expressão pode ser simplificada.
string.literal.equality=Literais de String deveriam ser comparados com "equals()", não com ''{0}''.
super.constructor.call=Chamada desnecessária ao construtor da superclasse sem argumentos.
unnecessary.nullcheck.with.instanceof=Verificação de nulidade desnecessária com o operador instanceof.
unnecessary.paren.assign=Parênteses desnecessários ao redor do lado direito da atribuição.
unnecessary.paren.expr=Parênteses desnecessários ao redor da expressão.
unnecessary.paren.ident=Parênteses desnecessários ao redor do identificador ''{0}''.
unnecessary.paren.lambda=Parênteses desnecessários em torno do valor lambda.
unnecessary.paren.literal=Parênteses desnecessários em torno do literal ''{0}''.
unnecessary.paren.return=Parênteses desnecessários em torno do valor de retorno.
unnecessary.paren.string=Parênteses desnecessários em torno da cadeia {0}.
unnecessary.semicolon=Ponto-e-vírgula desnecessário.
unused.catch.parameter=O parâmetro catch não utilizado ''{0}'' não deve ter nome.
unused.lambda.parameter=O parâmetro lambda não utilizado ''{0}'' não deve ter nome.
unused.local.var=Variável local não utilizada '' {0} ''.
unused.named.local.var=Vari�vel local nomeada n�o utilizada '' {0} ''.
variable.declaration.usage.distance=A distância entre a declaração da variável ''{0}'' e o seu primeiro uso é {1}. O máximo permitido é {2}.
variable.declaration.usage.distance.extend=A distância entre a declaração da variável ''{0}'' e o seu primeiro uso é {1}. O máximo permitido é {2}. Considere tornar essa variável final se você ainda precisa armazenar o seu valor com antecedência (antes que chamadas de métodos que possam causar efeitos colaterais sobre o seu valor original).
when.should.be.used=A expressão ''when'' deve ser utilizada em vez de uma única instrução ''if'' no bloco case.
