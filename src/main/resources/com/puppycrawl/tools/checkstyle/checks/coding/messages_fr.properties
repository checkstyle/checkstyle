array.trailing.comma=La derni\u00C3\u00A8re valeur d''un tableau devrait \u00C3\u00AAtre suivie d''une virgule.
assignment.inner.avoid=\u00C3\u0089vitez d''affecter une valeur \u00C3\u00A0 une variable au sein d''une expression.
avoid.clone.method=\u00C3\u0089vitez d''utiliser la m\u00C3\u00A9thode de clonage.
avoid.double.brace.init=\u00C3\u0089vitez l''initialisation \u00C3\u00A0 double accolade.
avoid.finalizer.method=\u00C3\u0089vitez d''utiliser la m\u00C3\u00A9thode de finalisation.
constructors.declaration.grouping=Tous les constructeurs surcharg\u00E9s doivent \u00EAtre regroup\u00E9s. Le constructeur pr\u00E9c\u00E9dent se trouvait au num\u00E9ro de ligne \u00AB\u00A0{0}\u00A0\u00BB.
covariant.equals=Votre m\u00C3\u00A9thode equals compare uniquement les objets de votre classe. N''oubliez pas de surcharger la m\u00C3\u00A9thode equals(java.lang.Object).
declaration.order.access=La d\u00C3\u00A9finition des variables n''est pas tri\u00C3\u00A9e suivant leur port\u00C3\u00A9e.
declaration.order.constructor=La d\u00C3\u00A9finition des constructeurs n''appara\u00C3\u00AEt pas dans le bon ordre.
declaration.order.instance=La d\u00C3\u00A9finition des variables d''instance n''appara\u00C3\u00AEt pas dans le bon ordre.
declaration.order.static=La d\u00C3\u00A9finition des variables statiques n''appara\u00C3\u00AEt pas dans le bon ordre.
default.comes.last=Le cas "default" devrait apparaitre en dernier dans le bloc "switch".
default.comes.last.in.casegroup=La valeur par d\u00C3\u00A9faut doit \u00C3\u00AAtre la derni\u00C3\u00A8re \u00C3\u00A9tiquette dans le groupe de cas.
empty.statement=Instruction vide.
equals.avoid.null=Les cha\u00C3\u00AEnes litt\u00C3\u00A9rales devraient \u00C3\u00AAtre sur le c\u00C3\u00B4t\u00C3\u00A9 gauche d''une comparaison ''equals''.
equals.noEquals=La d\u00C3\u00A9finition de la m\u00C3\u00A9thode ''hashCode()'' doit toujours \u00C3\u00AAtre accompagn\u00C3\u00A9e de la d\u00C3\u00A9finition de la m\u00C3\u00A9thode ''equals()''.
equals.noHashCode=La d\u00C3\u00A9finition de la m\u00C3\u00A9thode ''equals()'' doit toujours \u00C3\u00AAtre accompagn\u00C3\u00A9e de la d\u00C3\u00A9finition de la m\u00C3\u00A9thode ''hashCode()''.
equalsIgnoreCase.avoid.null=Les cha\u00C3\u00AEnes litt\u00C3\u00A9rales devraient \u00C3\u00AAtre sur le c\u00C3\u00B4t\u00C3\u00A9 gauche d''une comparaison ''equalsIgnoreCase''.
explicit.init=L''initialisation explicite de la variable ''{0}'' \u00C3\u00A0 la valeur ''{1}'' est inutile, c''est la valeur par d\u00C3\u00A9faut pour ce type.
fall.through=Le cas pr\u00C3\u00A9c\u00C3\u00A9dent du "switch" ne contient pas de break, return, yield, throw ou continue.
fall.through.last=Le dernier cas du "switch" ne contient pas de break, return, yield, throw ou continue.
final.variable=La variable ''{0}'' devrait \u00C3\u00AAtre finale.
hidden.field=''{0}'' masque un attribut.
illegal.catch=Catcher l''exception ''{0}'' est prohib\u00C3\u00A9.
illegal.throw=Lancer ''{0}'' n''est pas autoris\u00C3\u00A9.
illegal.token=Il est interdit d''utiliser ''{0}''.
illegal.token.text=Cha\u00C3\u00AEne de caract\u00C3\u00A8res interdite ''{0}''.
illegal.type=L''utilisation du type ''{0}'' est interdit.
inline.conditional.avoid=L''utilisation de l''op\u00C3\u00A9rateur conditionel est prohib\u00C3\u00A9e.
instantiation.avoid=L''instantiation de la classe {0} est prohib\u00C3\u00A9e.
magic.number=''{0}'' devrait \u00C3\u00AAtre d\u00C3\u00A9fini comme une constante.
matchxpath.match=Structure de code ill\u00C3\u00A9gale d\u00C3\u00A9tect\u00C3\u00A9e.
mismatch.package.directory=Le nom du package n''est pas identique au r\u00C3\u00A9pertoire.
missing.ctor=Il manque un constructeur \u00C3\u00A0 la classe.
missing.package.declaration=D\u00C3\u00A9claration de package manquante.
missing.super.call=La m\u00C3\u00A9thode ''{0}'' devrait appeler ''super.{0}''.
missing.switch.default=Il manque le cas "default" dans le bloc "switch".
modified.control.variable=La variable de contr\u00C3\u00B4le ''{0}'' est modifi\u00C3\u00A9e.
multiple.statements.line=Une seule instruction par ligne autoris\u00C3\u00A9e.
multiple.string.literal=La cha\u00C3\u00AEne {0} appara\u00C3\u00AEt {1} fois dans le fichier.
multiple.variable.declarations=Ne d\u00C3\u00A9clarez pas plus d''une variable par ligne.
multiple.variable.declarations.comma=Chaque d\u00C3\u00A9claration de variable doit faire l''objet d''une instruction \u00C3\u00A0 part.
nested.for.depth=Le nombre de ''for'' imbriqu\u00C3\u00A9s est de {0, number, integer}, alors que le maximum autoris\u00C3\u00A9 est de {1, number, integer}.
nested.if.depth=Le nombre de ''if'' imbriqu\u00C3\u00A9s est de {0,number,integer}, alors que le maximum autoris\u00C3\u00A9 est de {1,number,integer}.
nested.try.depth=Le nombre de ''try'' imbriqu\u00C3\u00A9s est de {0,number,integer}, alors que le maximum autoris\u00C3\u00A9 est de {1,number,integer}.
no.array.trailing.comma=Le tableau ne doit pas contenir de virgule.
no.enum.trailing.comma=Enum ne doit pas contenir de virgule.
overload.methods.declaration=Toutes les m\u00C3\u00A9thodes surcharg\u00C3\u00A9es doivent \u00C3\u00AAtre plac\u00C3\u00A9es c\u00C3\u00B4te \u00C3\u00A0 c\u00C3\u00B4te. Placer des m\u00C3\u00A9thodes non surcharg\u00C3\u00A9es entre des m\u00C3\u00A9thodes surcharg\u00C3\u00A9es avec le m\u00C3\u00AAme type est une violation. La m\u00C3\u00A9thode surcharg\u00C3\u00A9e pr\u00C3\u00A9c\u00C3\u00A9dente se trouve \u00C3\u00A0 la ligne '' {0} ''.
parameter.assignment=Il est interdit d''affecter une valeur au param\u00C3\u00A8tre ''{0}''.
require.this.method=L''appel \u00C3\u00A0 la m\u00C3\u00A9thode ''{0}'' n\u00C3\u00A9cessite l''utilisation de "{1}this.".
require.this.variable=La r\u00C3\u00A9f\u00C3\u00A9rence \u00C3\u00A0 la variable d''instance ''{0}'' doit utiliser "{1}this.".
return.count=Le nombre de return est de {0,number,integer} alors que le maximum m\u00C3\u00A9thodes non-nulles/lambdas {1,number,integer}.
return.countVoid=Le nombre de return est de {0,number,integer} alors que le maximum autoris\u00C3\u00A9 void methods/constructors/lambdas est de {1,number,integer}.
simplify.boolReturn=Le test peut \u00C3\u00AAtre supprim\u00C3\u00A9 et l''expression directement retourn\u00C3\u00A9e.
simplify.expression=L''expression peut \u00C3\u00AAtre simplifi\u00C3\u00A9e.
string.literal.equality=Les cha\u00C3\u00AEnes de caract\u00C3\u00A8res litt\u00C3\u00A9rales devraient \u00C3\u00AAtre compar\u00C3\u00A9es avec la m\u00C3\u00A9thode ''equals()'' et pas avec ''{0}''.
super.constructor.call=Appel inutile au constructeur de superclasse sans arguments.
unnecessary.paren.assign=Parenth\u00C3\u00A8ses inutiles autour la partie droite de l''affectation.
unnecessary.paren.expr=Parenth\u00C3\u00A8ses inutiles autour de l''expression.
unnecessary.paren.ident=Parenth\u00C3\u00A8ses inutiles autour de l''identifiant ''{0}''.
unnecessary.paren.lambda=Parenth\u00C3\u00A8ses inutiles autour de la valeur lambda.
unnecessary.paren.literal=Parenth\u00C3\u00A8ses inutiles autour de la cha\u00C3\u00AEne litt\u00C3\u00A9rale ''{0}''.
unnecessary.paren.return=Parenth\u00C3\u00A8ses inutiles autour de la valeur de retour.
unnecessary.paren.string=Parenth\u00C3\u00A8ses inutiles autour de la cha\u00C3\u00AEne {0}.
unnecessary.semicolon=Point-virgule inutile.
unused.local.var=Variable locale non utilis\u00C3\u00A9e ''{0}''.
variable.declaration.usage.distance=La distance entre la d\u00C3\u00A9claration de la variable ''{0}'' et sa premi\u00C3\u00A8re utilisation est de {1}, alors que le maximum autoris\u00C3\u00A9 est de {2}.
variable.declaration.usage.distance.extend=La distance entre la d\u00C3\u00A9claration de la variable ''{0}'' et sa premi\u00C3\u00A8re utilisation est de {1}, alors que le maximum autoris\u00C3\u00A9 est de {2}. Envisagez de rendre cette variable finale si vous avez encore besoin de stocker sa valeur \u00C3\u00A0 l''avance (avant les appels de m\u00C3\u00A9thode qui pourrait avoir des effets secondaires sur la valeur d''origine).
