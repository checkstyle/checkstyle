array.trailing.comma=La derni√®re valeur d''un tableau devrait √™tre suivie d''une virgule.
assignment.inner.avoid=√âvitez d''affecter une valeur √† une variable au sein d''une expression.
avoid.clone.method=√âvitez d''utiliser la m√©thode de clonage.
avoid.double.brace.init=√âvitez l''initialisation √† double accolade.
avoid.finalizer.method=√âvitez d''utiliser la m√©thode de finalisation.
constructors.declaration.grouping=Les constructeurs doivent √™tre regroup√©s. Le dernier constructeur group√© est d√©clar√© √† la ligne ''{0}''.
covariant.equals=Votre m√©thode equals compare uniquement les objets de votre classe. N''oubliez pas de surcharger la m√©thode equals(java.lang.Object).
declaration.order.access=La d√©finition des variables n''est pas tri√©e suivant leur port√©e.
declaration.order.constructor=La d√©finition des constructeurs n''appara√Æt pas dans le bon ordre.
declaration.order.instance=La d√©finition des variables d''instance n''appara√Æt pas dans le bon ordre.
declaration.order.static=La d√©finition des variables statiques n''appara√Æt pas dans le bon ordre.
default.comes.last=Le cas "default" devrait apparaitre en dernier dans le bloc "switch".
default.comes.last.in.casegroup=La valeur par d√©faut doit √™tre la derni√®re √©tiquette dans le groupe de cas.
empty.statement=Instruction vide.
equals.avoid.null=Les cha√Ænes litt√©rales devraient √™tre sur le c√¥t√© gauche d''une comparaison ''equals''.
equals.noEquals=La d√©finition de la m√©thode ''hashCode()'' doit toujours √™tre accompagn√©e de la d√©finition de la m√©thode ''equals()''.
equals.noHashCode=La d√©finition de la m√©thode ''equals()'' doit toujours √™tre accompagn√©e de la d√©finition de la m√©thode ''hashCode()''.
equalsIgnoreCase.avoid.null=Les cha√Ænes litt√©rales devraient √™tre sur le c√¥t√© gauche d''une comparaison ''equalsIgnoreCase''.
explicit.init=L''initialisation explicite de la variable ''{0}'' √† la valeur ''{1}'' est inutile, c''est la valeur par d√©faut pour ce type.
fall.through=Le cas pr√©c√©dent du "switch" ne contient pas de break, return, yield, throw ou continue.
fall.through.last=Le dernier cas du "switch" ne contient pas de break, return, yield, throw ou continue.
final.variable=La variable ''{0}'' devrait √™tre finale.
hidden.field=''{0}'' masque un attribut.
illegal.catch=Catcher l''exception ''{0}'' est prohib√©.
illegal.throw=Lancer ''{0}'' n''est pas autoris√©.
illegal.token=Il est interdit d''utiliser ''{0}''.
illegal.token.text=Cha√Æne de caract√®res interdite ''{0}''.
illegal.type=L''utilisation du type ''{0}'' est interdit.
inline.conditional.avoid=L''utilisation de l''op√©rateur conditionel est prohib√©e.
instantiation.avoid=L''instantiation de la classe {0} est prohib√©e.
magic.number=''{0}'' devrait √™tre d√©fini comme une constante.
matchxpath.match=Structure de code ill√©gale d√©tect√©e.
mismatch.package.directory=Le nom du package n''est pas identique au r√©pertoire.
missing.ctor=Il manque un constructeur √† la classe.
missing.package.declaration=D√©claration de package manquante.
missing.super.call=La m√©thode ''{0}'' devrait appeler ''super.{0}''.
missing.switch.default=Il manque le cas "default" dans le bloc "switch".
missing.switch.nullcase=Switch utilisant des types de rÈfÈrence doit avoir un cas nul.
modified.control.variable=La variable de contr√¥le ''{0}'' est modifi√©e.
multiple.statements.line=Une seule instruction par ligne autoris√©e.
multiple.string.literal=La cha√Æne {0} appara√Æt {1} fois dans le fichier.
multiple.variable.declarations=Ne d√©clarez pas plus d''une variable par ligne.
multiple.variable.declarations.comma=Chaque d√©claration de variable doit faire l''objet d''une instruction √† part.
nested.for.depth=Le nombre de ''for'' imbriqu√©s est de {0, number, integer}, alors que le maximum autoris√© est de {1, number, integer}.
nested.if.depth=Le nombre de ''if'' imbriqu√©s est de {0,number,integer}, alors que le maximum autoris√© est de {1,number,integer}.
nested.try.depth=Le nombre de ''try'' imbriqu√©s est de {0,number,integer}, alors que le maximum autoris√© est de {1,number,integer}.
no.array.trailing.comma=Le tableau ne doit pas contenir de virgule.
no.enum.trailing.comma=Enum ne doit pas contenir de virgule.
overload.methods.declaration=Toutes les m√©thodes surcharg√©es doivent √™tre plac√©es les unes √† c√¥t√© des autres. M√©thode surcharg√©e pr√©c√©dente situ√©e √† la ligne ''{0}''.
parameter.assignment=Il est interdit d''affecter une valeur au param√®tre ''{0}''.
require.this.method=L''appel √† la m√©thode ''{0}'' n√©cessite l''utilisation de "{1}this.".
require.this.variable=La r√©f√©rence √† la variable d''instance ''{0}'' doit utiliser "{1}this.".
return.count=Le nombre de return est de {0,number,integer} alors que le maximum m√©thodes non-nulles/lambdas {1,number,integer}.
return.countVoid=Le nombre de return est de {0,number,integer} alors que le maximum autoris√© void methods/constructors/lambdas est de {1,number,integer}.
simplify.boolReturn=Le test peut √™tre supprim√© et l''expression directement retourn√©e.
simplify.expression=L''expression peut √™tre simplifi√©e.
string.literal.equality=Les cha√Ænes de caract√®res litt√©rales devraient √™tre compar√©es avec la m√©thode ''equals()'' et pas avec ''{0}''.
super.constructor.call=Appel inutile au constructeur de superclasse sans arguments.
unnecessary.paren.assign=Parenth√®ses inutiles autour la partie droite de l''affectation.
unnecessary.paren.expr=Parenth√®ses inutiles autour de l''expression.
unnecessary.paren.ident=Parenth√®ses inutiles autour de l''identifiant ''{0}''.
unnecessary.paren.lambda=Parenth√®ses inutiles autour de la valeur lambda.
unnecessary.paren.literal=Parenth√®ses inutiles autour de la cha√Æne litt√©rale ''{0}''.
unnecessary.paren.return=Parenth√®ses inutiles autour de la valeur de retour.
unnecessary.paren.string=Parenth√®ses inutiles autour de la cha√Æne {0}.
unnecessary.semicolon=Point-virgule inutile.
unused.catch.parameter=Le param√®tre de capture inutilis√© ''{0}'' ne doit pas √™tre nomm√©.
unused.lambda.parameter=Le param√®tre lambda inutilis√© ''{0}'' ne doit pas √™tre nomm√©.
unused.local.var=Variable locale non utilis√©e ''{0}''.
unused.local.method=InutilisÈe locale non utilis√©e ''{0}''.
unused.named.local.var=Variable locale nomm e inutilis e ''{0}''.
variable.declaration.usage.distance=La distance entre la d√©claration de la variable ''{0}'' et sa premi√®re utilisation est de {1}, alors que le maximum autoris√© est de {2}.
variable.declaration.usage.distance.extend=La distance entre la d√©claration de la variable ''{0}'' et sa premi√®re utilisation est de {1}, alors que le maximum autoris√© est de {2}. Envisagez de rendre cette variable finale si vous avez encore besoin de stocker sa valeur √† l''avance (avant les appels de m√©thode qui pourrait avoir des effets secondaires sur la valeur d''origine).
when.should.be.used=L'expression ''when'' doit √™tre utilis√©e √† la place d'une seule instruction ''if'' dans le bloc case.
