array.trailing.comma=El array deber√≠a llevar una coma al final.
assignment.inner.avoid=Deben evitarse las asignaciones internas.
avoid.clone.method=Evite el uso de m√©todo clone.
avoid.double.brace.init=Evite la inicializaci√≥n de llaves dobles.
avoid.finalizer.method=Evite el uso de m√©todo de finalizador.
constructors.declaration.grouping=Todos los constructores deben agruparse. El constructor anterior estaba en la l√≠nea n√∫mero ''{0}''.
covariant.equals=equals covariante sin sobrescribir equals(java.lang.Object).
declaration.order.access=Definici√≥n de acceso a variable en orden incorrecto.
declaration.order.constructor=Definici√≥n de constructor en orden incorrecto.
declaration.order.instance=Definici√≥n de variable de instancia en orden incorrecto.
declaration.order.static=Definici√≥n de variable static en orden incorrecto.
default.comes.last=La etiqueta default debe ser la √∫ltima etiqueta en el switch.
default.comes.last.in.casegroup=El valor predeterminado debe ser la √∫ltima etiqueta en el grupo de casos.
empty.statement=Sentencia vac√≠a.
equals.avoid.null=Expresiones literales de cadena deben estar en el lado izquierdo de un igual comparaci√≥n.
equals.noEquals=Definici√≥n de ''hashCode()'' sin la correspondiente definici√≥n de ''equals()''.
equals.noHashCode=Definici√≥n de ''equals()'' sin la correspondiente definici√≥n de ''hashCode()''.
equalsIgnoreCase.avoid.null=Expresiones literales de cadena deben estar en el lado izquierdo de una comparaci√≥n equalsIgnoreCase.
explicit.init=La variable ''{0}'' se inicializa explicitamente a ''{1}'' (valor por defecto para su tipo).
fall.through=Ca√≠da desde la etiqueta anterior en la sentencia switch.
fall.through.last=Caen a trav√©s de la √∫ltima rama de la sentencia switch.
final.variable=La variable ''{0}'' debe declararse final.
hidden.field=''{0}'' oculta un campo.
illegal.catch=Capturar la excepci√≥n ''{0}'' no est√° permitido.
illegal.throw=Lanzar ''{0}'' no est√° permitido.
illegal.token=El uso de ''{0}'' no esta permitido.
illegal.token.text=El texto del token coincide con el patr√≥n ilegal ''{0}''.
illegal.type=El uso de tipo ''{0}'' no est√° permitida.
inline.conditional.avoid=Evitar los condicionales en l√≠nea.
instantiation.avoid=Deber√≠a evitarse la instanciaci√≥n de {0}.
magic.number=''{0}'' es un n√∫mero m√°gico.
matchxpath.match=Se detect√≥ una estructura de c√≥digo ilegal.
mismatch.package.directory=El nombre del paquete no es el mismo que el directorio.
missing.ctor=La clase deber√≠a definir un constructor.
missing.package.declaration=Falta la declaraci√≥n de paquete.
missing.super.call=El m√©todo ''{0}'' deber√≠a llamar a ''super.{0}''.
missing.switch.default=switch sin etiqueta "default".
missing.switch.nullcase=Switch usando tipos de referencia deber√≠a tener un caso nulo.
modified.control.variable=Se modifica la variable de control ''{0}''.
multiple.statements.line=S√≥lo una declaraci√≥n por l√≠nea permitido.
multiple.string.literal=La cadena {0} aparece {1} veces en el fichero.
multiple.variable.declarations=S√≥lo se permite una definici√≥n de variable por l√≠nea.
multiple.variable.declarations.comma=Cada declaraci√≥n de variable debe estar en su l√≠nea.
nested.for.depth=Anidado para la profundidad es {0,number,integer} (m√°ximo permitido es {1,number,integer}).
nested.if.depth=La profundidad de if-else anidados es {0,number,integer} (m√°ximo permitido es {1,number,integer}).
nested.try.depth=La profundidad de try anidados es {0,number,integer} (m√°ximo permitido es {1,number,integer}).
no.array.trailing.comma=La matriz no debe contener una coma final.
no.enum.trailing.comma=Enum no debe contener una coma final.
overload.methods.declaration=Todos los m√©todos sobrecargados deben colocarse uno al lado del otro. M√©todo sobrecargado anterior ubicado en la l√≠nea ''{0}''.
parameter.assignment=No esta permitida la asignaci√≥n del par√°metro ''{0}''.
require.this.method=La llamada al m√©todo ''{0}'' necesita "{1}this.".
require.this.variable=La referencia a la variable de instancia ''{0}'' necesita "{1}this.".
return.count=El n√∫mero de sentencias return es {0,number,integer} (max permitido para m√©todos no vac√≠os / lambdas es {1,number,integer}).
return.countVoid=El n√∫mero de sentencias return es {0,number,integer} (max permitido para m√©todos / constructores / lambdas vac√≠os {1,number,integer}).
simplify.boolReturn=Se puede eliminar la l√≥gica condicional.
simplify.expression=Se puede simplificar la expresi√≥n.
string.literal.equality=Las cadenas literales deben compararse usando equals(), no ''{0}''.
super.constructor.call=Llamada innecesaria al constructor de superclase sin argumentos.
unnecessary.paren.assign=Par√©ntesis innecesarios alrededor de la parte derecha de una asignaci√≥n.
unnecessary.paren.expr=Par√©ntesis innecesarios alrededor de la expresi√≥n.
unnecessary.paren.ident=Par√©ntesis innecesarios alrededor del identificador ''{0}''.
unnecessary.paren.lambda=Par√©ntesis innecesarios alrededor del valor lambda.
unnecessary.paren.literal=Par√©ntesis innecesarios alrededor del literal ''{0}''.
unnecessary.paren.return=Par√©ntesis innecesarios alrededor del valor de retorno.
unnecessary.paren.string=Par√©ntesis innecesarios alrededor de la cadena {0}.
unnecessary.semicolon=Punto y coma innecesario.
unused.catch.parameter=El par√°metro de captura no utilizado ''{0}'' no debe tener nombre.
unused.lambda.parameter=El par·metro lambda no utilizado ''{0}'' no debe tener nombre.
outdated.api.usage=Variable local no utilizado '' {0} ''.
unused.local.var=Variable local no utilizada '' {0} ''.
unused.named.local.var=Variable local con nombre no utilizada ''{0}''.
variable.declaration.usage.distance=La distancia entre la declaraci√≥n de la variable ''{0}'' y su primer uso es {1}, pero el m√°ximo permitido es {2}.
variable.declaration.usage.distance.extend=La distancia entre la declaraci√≥n de la variable ''{0}'' y su primer uso es {1}, pero el m√°ximo permitido es {2}. Considere la posibilidad de hacer esa variable como final si usted todav√≠a tiene que almacenar su valor con antelaci√≥n (antes de llamadas a m√©todos que puedan hacer efecto secundario en el valor original).
when.should.be.used=Se debe usar la expresi√≥n ''when'' en lugar de una sola declaraci√≥n ''if'' en el bloque de casos.
