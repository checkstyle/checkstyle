array.trailing.comma=El array deber\u00C3\u00ADa llevar una coma al final.
assignment.inner.avoid=Deben evitarse las asignaciones internas.
avoid.clone.method=Evite el uso de m\u00C3\u00A9todo clone.
avoid.double.brace.init=Evite la inicializaci\u00C3\u00B3n de llaves dobles.
avoid.finalizer.method=Evite el uso de m\u00C3\u00A9todo de finalizador.
constructors.declaration.grouping=Todos los constructores sobrecargados deben agruparse. El constructor anterior estaba en la l\u00EDnea n\u00FAmero ''{0}''.
covariant.equals=equals covariante sin sobrescribir equals(java.lang.Object).
declaration.order.access=Definici\u00C3\u00B3n de acceso a variable en orden incorrecto.
declaration.order.constructor=Definici\u00C3\u00B3n de constructor en orden incorrecto.
declaration.order.instance=Definici\u00C3\u00B3n de variable de instancia en orden incorrecto.
declaration.order.static=Definici\u00C3\u00B3n de variable static en orden incorrecto.
default.comes.last=La etiqueta default debe ser la \u00C3\u00BAltima etiqueta en el switch.
default.comes.last.in.casegroup=El valor predeterminado debe ser la \u00C3\u00BAltima etiqueta en el grupo de casos.
empty.statement=Sentencia vac\u00C3\u00ADa.
equals.avoid.null=Expresiones literales de cadena deben estar en el lado izquierdo de un igual comparaci\u00C3\u00B3n.
equals.noEquals=Definici\u00C3\u00B3n de ''hashCode()'' sin la correspondiente definici\u00C3\u00B3n de ''equals()''.
equals.noHashCode=Definici\u00C3\u00B3n de ''equals()'' sin la correspondiente definici\u00C3\u00B3n de ''hashCode()''.
equalsIgnoreCase.avoid.null=Expresiones literales de cadena deben estar en el lado izquierdo de una comparaci\u00C3\u00B3n equalsIgnoreCase.
explicit.init=La variable ''{0}'' se inicializa explicitamente a ''{1}'' (valor por defecto para su tipo).
fall.through=Ca\u00C3\u00ADda desde la etiqueta anterior en la sentencia switch.
fall.through.last=Caen a trav\u00C3\u00A9s de la \u00C3\u00BAltima rama de la sentencia switch.
final.variable=La variable ''{0}'' debe declararse final.
hidden.field=''{0}'' oculta un campo.
illegal.catch=Capturar la excepci\u00C3\u00B3n ''{0}'' no est\u00C3\u00A1 permitido.
illegal.throw=Lanzar ''{0}'' no est\u00C3\u00A1 permitido.
illegal.token=El uso de ''{0}'' no esta permitido.
illegal.token.text=El texto del token coincide con el patr\u00C3\u00B3n ilegal ''{0}''.
illegal.type=El uso de tipo ''{0}'' no est\u00C3\u00A1 permitida.
inline.conditional.avoid=Evitar los condicionales en l\u00C3\u00ADnea.
instantiation.avoid=Deber\u00C3\u00ADa evitarse la instanciaci\u00C3\u00B3n de {0}.
magic.number=''{0}'' es un n\u00C3\u00BAmero m\u00C3\u00A1gico.
matchxpath.match=Se detect\u00C3\u00B3 una estructura de c\u00C3\u00B3digo ilegal.
mismatch.package.directory=El nombre del paquete no es el mismo que el directorio.
missing.ctor=La clase deber\u00C3\u00ADa definir un constructor.
missing.package.declaration=Falta la declaraci\u00C3\u00B3n de paquete.
missing.super.call=El m\u00C3\u00A9todo ''{0}'' deber\u00C3\u00ADa llamar a ''super.{0}''.
missing.switch.default=switch sin etiqueta "default".
modified.control.variable=Se modifica la variable de control ''{0}''.
multiple.statements.line=S\u00C3\u00B3lo una declaraci\u00C3\u00B3n por l\u00C3\u00ADnea permitido.
multiple.string.literal=La cadena {0} aparece {1} veces en el fichero.
multiple.variable.declarations=S\u00C3\u00B3lo se permite una definici\u00C3\u00B3n de variable por l\u00C3\u00ADnea.
multiple.variable.declarations.comma=Cada declaraci\u00C3\u00B3n de variable debe estar en su l\u00C3\u00ADnea.
nested.for.depth=Anidado para la profundidad es {0,number,integer} (m\u00C3\u00A1ximo permitido es {1,number,integer}).
nested.if.depth=La profundidad de if-else anidados es {0,number,integer} (m\u00C3\u00A1ximo permitido es {1,number,integer}).
nested.try.depth=La profundidad de try anidados es {0,number,integer} (m\u00C3\u00A1ximo permitido es {1,number,integer}).
no.array.trailing.comma=La matriz no debe contener una coma final.
no.enum.trailing.comma=Enum no debe contener una coma final.
overload.methods.declaration=Todos los m\u00C3\u00A9todos sobrecargados deben colocarse uno al lado del otro. Colocar m\u00C3\u00A9todos no sobrecargados entre m\u00C3\u00A9todos sobrecargados con el mismo tipo es una violaci\u00C3\u00B3n. M\u00C3\u00A9todo sobrecargado anterior ubicado en la l\u00C3\u00ADnea ''{0} ''.
parameter.assignment=No esta permitida la asignaci\u00C3\u00B3n del par\u00C3\u00A1metro ''{0}''.
require.this.method=La llamada al m\u00C3\u00A9todo ''{0}'' necesita "{1}this.".
require.this.variable=La referencia a la variable de instancia ''{0}'' necesita "{1}this.".
return.count=El n\u00C3\u00BAmero de sentencias return es {0,number,integer} (max permitido para m\u00C3\u00A9todos no vac\u00C3\u00ADos / lambdas es {1,number,integer}).
return.countVoid=El n\u00C3\u00BAmero de sentencias return es {0,number,integer} (max permitido para m\u00C3\u00A9todos / constructores / lambdas vac\u00C3\u00ADos {1,number,integer}).
simplify.boolReturn=Se puede eliminar la l\u00C3\u00B3gica condicional.
simplify.expression=Se puede simplificar la expresi\u00C3\u00B3n.
string.literal.equality=Las cadenas literales deben compararse usando equals(), no ''{0}''.
super.constructor.call=Llamada innecesaria al constructor de superclase sin argumentos.
unnecessary.paren.assign=Par\u00C3\u00A9ntesis innecesarios alrededor de la parte derecha de una asignaci\u00C3\u00B3n.
unnecessary.paren.expr=Par\u00C3\u00A9ntesis innecesarios alrededor de la expresi\u00C3\u00B3n.
unnecessary.paren.ident=Par\u00C3\u00A9ntesis innecesarios alrededor del identificador ''{0}''.
unnecessary.paren.lambda=Par\u00C3\u00A9ntesis innecesarios alrededor del valor lambda.
unnecessary.paren.literal=Par\u00C3\u00A9ntesis innecesarios alrededor del literal ''{0}''.
unnecessary.paren.return=Par\u00C3\u00A9ntesis innecesarios alrededor del valor de retorno.
unnecessary.paren.string=Par\u00C3\u00A9ntesis innecesarios alrededor de la cadena {0}.
unnecessary.semicolon=Punto y coma innecesario.
unused.local.var=Variable local no utilizada '' {0} ''.
variable.declaration.usage.distance=La distancia entre la declaraci\u00C3\u00B3n de la variable ''{0}'' y su primer uso es {1}, pero el m\u00C3\u00A1ximo permitido es {2}.
variable.declaration.usage.distance.extend=La distancia entre la declaraci\u00C3\u00B3n de la variable ''{0}'' y su primer uso es {1}, pero el m\u00C3\u00A1ximo permitido es {2}. Considere la posibilidad de hacer esa variable como final si usted todav\u00C3\u00ADa tiene que almacenar su valor con antelaci\u00C3\u00B3n (antes de llamadas a m\u00C3\u00A9todos que puedan hacer efecto secundario en el valor original).
