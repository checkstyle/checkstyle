array.trailing.comma=El array debería llevar una coma al final.
assignment.inner.avoid=Deben evitarse las asignaciones internas.
avoid.clone.method=Evite el uso de método clone.
avoid.double.brace.init=Evite la inicialización de llaves dobles.
avoid.finalizer.method=Evite el uso de método de finalizador.
constructors.declaration.grouping=Todos los constructores deben agruparse. El constructor anterior estaba en la línea número ''{0}''.
covariant.equals=equals covariante sin sobrescribir equals(java.lang.Object).
declaration.order.access=Definición de acceso a variable en orden incorrecto.
declaration.order.constructor=Definición de constructor en orden incorrecto.
declaration.order.instance=Definición de variable de instancia en orden incorrecto.
declaration.order.static=Definición de variable static en orden incorrecto.
default.comes.last=La etiqueta default debe ser la última etiqueta en el switch.
default.comes.last.in.casegroup=El valor predeterminado debe ser la última etiqueta en el grupo de casos.
empty.statement=Sentencia vacía.
equals.avoid.null=Expresiones literales de cadena deben estar en el lado izquierdo de un igual comparación.
equals.noEquals=Definición de ''hashCode()'' sin la correspondiente definición de ''equals()''.
equals.noHashCode=Definición de ''equals()'' sin la correspondiente definición de ''hashCode()''.
equalsIgnoreCase.avoid.null=Expresiones literales de cadena deben estar en el lado izquierdo de una comparación equalsIgnoreCase.
explicit.init=La variable ''{0}'' se inicializa explicitamente a ''{1}'' (valor por defecto para su tipo).
fall.through=Caída desde la etiqueta anterior en la sentencia switch.
fall.through.last=Caen a través de la última rama de la sentencia switch.
final.variable=La variable ''{0}'' debe declararse final.
hidden.field=''{0}'' oculta un campo.
illegal.catch=Capturar la excepción ''{0}'' no está permitido.
illegal.throw=Lanzar ''{0}'' no está permitido.
illegal.token=El uso de ''{0}'' no esta permitido.
illegal.token.text=El texto del token coincide con el patrón ilegal ''{0}''.
illegal.type=El uso de tipo ''{0}'' no está permitida.
inline.conditional.avoid=Evitar los condicionales en línea.
instantiation.avoid=Debería evitarse la instanciación de {0}.
magic.number=''{0}'' es un número mágico.
matchxpath.match=Se detectó una estructura de código ilegal.
mismatch.package.directory=El nombre del paquete no es el mismo que el directorio.
missing.ctor=La clase debería definir un constructor.
missing.package.declaration=Falta la declaración de paquete.
missing.super.call=El método ''{0}'' debería llamar a ''super.{0}''.
missing.switch.default=switch sin etiqueta "default".
missing.switch.nullcase=Switch usando tipos de referencia debería tener un caso nulo.
modified.control.variable=Se modifica la variable de control ''{0}''.
multiple.statements.line=Sólo una declaración por línea permitido.
multiple.string.literal=La cadena {0} aparece {1} veces en el fichero.
multiple.variable.declarations=Sólo se permite una definición de variable por línea.
multiple.variable.declarations.comma=Cada declaración de variable debe estar en su línea.
nested.for.depth=Anidado para la profundidad es {0,number,integer} (máximo permitido es {1,number,integer}).
nested.if.depth=La profundidad de if-else anidados es {0,number,integer} (máximo permitido es {1,number,integer}).
nested.try.depth=La profundidad de try anidados es {0,number,integer} (máximo permitido es {1,number,integer}).
no.array.trailing.comma=La matriz no debe contener una coma final.
no.enum.trailing.comma=Enum no debe contener una coma final.
overload.methods.declaration=Todos los métodos sobrecargados deben colocarse uno al lado del otro. Método sobrecargado anterior ubicado en la línea ''{0}''.
parameter.assignment=No esta permitida la asignación del parámetro ''{0}''.
require.this.method=La llamada al método ''{0}'' necesita "{1}this.".
require.this.variable=La referencia a la variable de instancia ''{0}'' necesita "{1}this.".
return.count=El número de sentencias return es {0,number,integer} (max permitido para métodos no vacíos / lambdas es {1,number,integer}).
return.countVoid=El número de sentencias return es {0,number,integer} (max permitido para métodos / constructores / lambdas vacíos {1,number,integer}).
simplify.boolReturn=Se puede eliminar la lógica condicional.
simplify.expression=Se puede simplificar la expresión.
string.literal.equality=Las cadenas literales deben compararse usando equals(), no ''{0}''.
super.constructor.call=Llamada innecesaria al constructor de superclase sin argumentos.
unnecessary.nullcheck.with.instanceof=Comprobación de nulidad innecesaria con el operador instanceof en una expresión condicional.
unnecessary.paren.assign=Paréntesis innecesarios alrededor de la parte derecha de una asignación.
unnecessary.paren.expr=Paréntesis innecesarios alrededor de la expresión.
unnecessary.paren.ident=Paréntesis innecesarios alrededor del identificador ''{0}''.
unnecessary.paren.lambda=Paréntesis innecesarios alrededor del valor lambda.
unnecessary.paren.literal=Paréntesis innecesarios alrededor del literal ''{0}''.
unnecessary.paren.return=Paréntesis innecesarios alrededor del valor de retorno.
unnecessary.paren.string=Paréntesis innecesarios alrededor de la cadena {0}.
unnecessary.semicolon=Punto y coma innecesario.
unused.catch.parameter=El parámetro de captura no utilizado ''{0}'' no debe tener nombre.
unused.lambda.parameter=El parámetro lambda no utilizado ''{0}'' no debe tener nombre.
unused.local.var=Variable local no utilizada '' {0} ''.
unused.named.local.var=Variable local con nombre no utilizada ''{0}''.
variable.declaration.usage.distance=La distancia entre la declaración de la variable ''{0}'' y su primer uso es {1}, pero el máximo permitido es {2}.
variable.declaration.usage.distance.extend=La distancia entre la declaración de la variable ''{0}'' y su primer uso es {1}, pero el máximo permitido es {2}. Considere la posibilidad de hacer esa variable como final si usted todavía tiene que almacenar su valor con antelación (antes de llamadas a métodos que puedan hacer efecto secundario en el valor original).
when.should.be.used=Se debe usar la expresión ''when'' en lugar de una sola declaración ''if'' en el bloque de casos.
